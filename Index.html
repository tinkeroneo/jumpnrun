<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Observed — Mobile (Multi-Level)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    html, body { margin:0; height:100%; background:#0b0d12; color:#e9eefc; }

    /* Fullscreen game */
    .game {
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      padding: 10px; box-sizing:border-box;
    }
    canvas{
      width: min(100%, 1000px);
      height: auto;
      aspect-ratio: 16/9;
      background:#0f1321;
      border:1px solid #1f2740;
      border-radius:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
    }

    /* Minimal HUD (not in the way) */
    .hud{
      position: fixed; left: 10px; top: 10px;
      display:flex; gap:8px; flex-wrap:wrap;
      z-index: 60;
      pointer-events: none;
    }
    .pill{
      pointer-events:none;
      background: rgba(15,19,33,.82);
      border: 1px solid rgba(31,39,64,.9);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color:#cdd7f5;
      backdrop-filter: blur(6px);
    }

    /* HUD buttons (need clicks) */
    .hud-btns{
      position: fixed; right: 10px; top: 10px;
      display:flex; gap:8px;
      z-index: 61;
    }
    button{
      background: rgba(26,33,64,.78);
      border:1px solid rgba(43,55,105,.85);
      color:#e9eefc;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 800;
      cursor: pointer;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(6px);
    }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: rgba(42,123,255,.82);
      border-color: rgba(42,123,255,.85);
    }

    /* Slide-up panel (hidden by default) */
    .sheet{
      position: fixed; left: 10px; right: 10px; bottom: 10px;
      max-width: 1000px;
      margin: 0 auto;
      background: rgba(18,22,37,.92);
      border: 1px solid rgba(31,39,64,.95);
      border-radius: 18px;
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
      transform: translateY(calc(100% - 54px));
      transition: transform .18s ease-out;
      z-index: 70;
      overflow:hidden;
      backdrop-filter: blur(10px);
    }
    .sheet.open{ transform: translateY(0); }
    .sheet-handle{
      display:flex; align-items:center; justify-content:space-between;
      padding: 10px 12px;
      gap:10px;
      cursor:pointer;
      user-select:none;
    }
    .grab{
      width: 44px; height: 5px; border-radius: 999px;
      background: rgba(233,238,252,.22);
      margin: 0 auto;
    }
    .sheet-title{ font-weight: 900; font-size: 13px; opacity:.95; }
    .muted{ color:#aab6da; font-size: 13px; line-height: 1.35; }
    .sheet-body{ padding: 0 12px 12px; }
    .box{
      background: rgba(15,19,33,.75);
      border:1px solid rgba(31,39,64,.9);
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
    }
    .comment{ font-size: 14px; line-height: 1.35; }
    code{ background:#0f1321; border:1px solid rgba(31,39,64,.9); border-radius: 10px; padding:2px 6px; }

    /* Big touch zones */
    body.game-no-gesture { overscroll-behavior:none; touch-action:none; }

    .touch-zones{
      position: fixed;
      left:0; right:0; bottom:0;
      height: 38vh;
      max-height: 280px;
      min-height: 160px;
      display:none;
      z-index: 50;
      pointer-events: none;
    }
    .zone{
      position:absolute; bottom:0; height:100%;
      pointer-events:auto;
      touch-action:none;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    .zone.move{ left:0; width:56%; }
    .zone.jump{ right:0; width:44%; }

    .zone::before{
      content:"";
      position:absolute; inset:12px;
      border-radius: 18px;
      border: 1px dashed rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.035), rgba(255,255,255,0));
    }
    .zone.move::after{
      content:"MOVE";
      position:absolute; left:22px; bottom:22px;
      font-weight:900; letter-spacing:.8px; font-size: 12px;
      color: rgba(233,238,252,.45);
    }
    .zone.jump::after{
      content:"JUMP";
      position:absolute; right:22px; bottom:22px;
      font-weight:900; letter-spacing:.8px; font-size: 12px;
      color: rgba(233,238,252,.45);
    }
    .dir-ind{
      position:absolute; left:0; right:0; top:18px;
      display:flex; justify-content:space-between; padding:0 22px;
      font-size:18px; font-weight:900;
      color: rgba(233,238,252,.30);
      pointer-events:none;
    }
    .dir-ind span.active{ color: rgba(42,123,255,.92); text-shadow: 0 0 18px rgba(42,123,255,.25); }

    /* Make sure sheet doesn't block touch zones too much on small screens */
    @media (max-width: 700px){
      .sheet{ left: 8px; right: 8px; bottom: 8px; }
      .sheet{ transform: translateY(calc(100% - 46px)); }
      .touch-zones{ height: 42vh; }
    }
  </style>
</head>

<body class="game-no-gesture">
  <div class="game">
    <canvas id="c" width="960" height="540" aria-label="Observed Prototype"></canvas>
  </div>

  <div class="hud" id="hud"></div>

  <div class="hud-btns">
    <button id="btnReset" class="primary" aria-label="Reset">Reset</button>
    <button id="btnInfo" aria-label="Info">Info</button>
    <button id="btnDelay" aria-label="Delay">Delay: an</button>
  </div>

  <div class="touch-zones" id="touchZones" aria-label="Touch Steuerung">
    <div class="zone move" id="zoneMove" aria-label="Bewegen (links/rechts nach Touch-Position)">
      <div class="dir-ind"><span id="indLeft">←</span><span id="indRight">→</span></div>
    </div>
    <div class="zone jump" id="zoneJump" aria-label="Springen"></div>
  </div>

  <div class="sheet" id="sheet" aria-label="Info Sheet">
    <div class="sheet-handle" id="sheetHandle">
      <div style="width:44px;"></div>
      <div style="display:flex; flex-direction:column; align-items:center; gap:6px; flex:1;">
        <div class="grab"></div>
        <div class="sheet-title">Observed — Info / Stats</div>
      </div>
      <div style="width:44px; text-align:right; font-weight:900; opacity:.8;">⌃</div>
    </div>
    <div class="sheet-body">
      <div class="muted">
        Handy: große Touch-Zonen unten. Links bewegen, rechts springen. Ziel: zur Tür. <br>
        Tastatur optional: <code>←</code><code>→</code>, <code>↑</code>/<code>Space</code>, <code>R</code>.
      </div>
      <div class="box">
        <div class="muted">Kommentar</div>
        <div class="comment" id="comment">—</div>
      </div>
      <div class="box">
        <div class="muted" id="debug"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ===== Config =====
  const CFG = {
    delayEnabled: true,
    feedbackDelayMs: 140,
    camDelayMs: 120,
    dtClamp: 1/30,
    moveAcc: 3200,
    maxSpeed: 420,
    friction: 2600,
    airControl: 0.55,
    jumpVel: 760,
    gravity: 1900,
    tile: 40,
  };

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  const els = {
    hud: document.getElementById("hud"),
    btnReset: document.getElementById("btnReset"),
    btnInfo: document.getElementById("btnInfo"),
    btnDelay: document.getElementById("btnDelay"),
    touchZones: document.getElementById("touchZones"),
    zoneMove: document.getElementById("zoneMove"),
    zoneJump: document.getElementById("zoneJump"),
    indLeft: document.getElementById("indLeft"),
    indRight: document.getElementById("indRight"),
    sheet: document.getElementById("sheet"),
    sheetHandle: document.getElementById("sheetHandle"),
    comment: document.getElementById("comment"),
    debug: document.getElementById("debug"),
  };

  // ===== Input (keyboard + touch) =====
  const keys = new Map();
  const touchKeys = new Map();

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.set(k, true);
    if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key)) e.preventDefault();
    if (k === "r") resetLevel(); // hard reset always works
  }, { passive:false });

  window.addEventListener("keyup", (e) => keys.set(e.key.toLowerCase(), false));

  function anyKeyDown(map, variants){
    for (const v of variants) if (map.get(v)) return true;
    return false;
  }

  function down(name){
    if (name === "left")  return anyKeyDown(keys, ["arrowleft","a"])  || !!touchKeys.get("arrowleft");
    if (name === "right") return anyKeyDown(keys, ["arrowright","d"]) || !!touchKeys.get("arrowright");
    if (name === "jump")  return anyKeyDown(keys, ["arrowup","w"," "]) || !!touchKeys.get(" ");
    return false;
  }

  // ===== Levels =====
  // Each level: { solids, spikes, goal, start, hint }
  const LEVELS = [
    {
      name: "L1",
      start: { x: 80, y: 360 },
      goal:  { x: 880, y: 380, w: 40, h: 80 },
      solids: [
        { x: 0, y: 460, w: 960, h: 80 },
        { x: 160, y: 390, w: 140, h: 20 },
        { x: 360, y: 330, w: 160, h: 20 },
        { x: 580, y: 360, w: 120, h: 20 },
        { x: 740, y: 300, w: 120, h: 20 },
        { x: 0, y: 0, w: 30, h: 540 },
        { x: 930, y: 0, w: 30, h: 540 },
      ],
      spikes: [
        { x: 300, y: 450, w: 60, h: 10 },
        { x: 520, y: 450, w: 60, h: 10 },
        { x: 700, y: 450, w: 60, h: 10 },
      ],
      hint: "Einfach zur Tür."
    },
    {
      name: "L2",
      start: { x: 70, y: 360 },
      goal:  { x: 880, y: 140, w: 40, h: 80 },
      solids: [
        { x: 0, y: 460, w: 960, h: 80 },
        { x: 120, y: 380, w: 120, h: 18 },
        { x: 280, y: 320, w: 120, h: 18 },
        { x: 450, y: 260, w: 120, h: 18 },
        { x: 630, y: 200, w: 140, h: 18 },
        { x: 820, y: 150, w: 90, h: 18 },
        { x: 0, y: 0, w: 30, h: 540 },
        { x: 930, y: 0, w: 30, h: 540 },
      ],
      spikes: [
        { x: 240, y: 450, w: 90, h: 10 },
        { x: 410, y: 450, w: 90, h: 10 },
        { x: 580, y: 450, w: 90, h: 10 },
      ],
      hint: "Höher. Und ruhiger."
    },
    {
      name: "L3",
      start: { x: 80, y: 360 },
      goal:  { x: 880, y: 380, w: 40, h: 80 },
      solids: [
        { x: 0, y: 460, w: 960, h: 80 },
        { x: 180, y: 410, w: 90, h: 16 },
        { x: 320, y: 370, w: 90, h: 16 },
        { x: 460, y: 330, w: 90, h: 16 },
        { x: 600, y: 290, w: 90, h: 16 },
        { x: 740, y: 250, w: 90, h: 16 },
        { x: 840, y: 420, w: 60, h: 16 }, // small near end
        { x: 0, y: 0, w: 30, h: 540 },
        { x: 930, y: 0, w: 30, h: 540 },
      ],
      spikes: [
        { x: 270, y: 450, w: 40, h: 10 },
        { x: 410, y: 450, w: 40, h: 10 },
        { x: 550, y: 450, w: 40, h: 10 },
        { x: 690, y: 450, w: 40, h: 10 },
      ],
      hint: "Kleine Sprünge zählen."
    }
  ];

  let levelIndex = 0;
  let world = null;

  function loadLevel(i){
    levelIndex = (i + LEVELS.length) % LEVELS.length;
    const L = LEVELS[levelIndex];
    // deep-ish copy
    world = {
      name: L.name,
      solids: L.solids.map(o => ({...o})),
      spikes: L.spikes.map(o => ({...o})),
      goal: {...L.goal},
      start: {...L.start},
      hint: L.hint
    };
    resetLevel(true);
  }

  // ===== Player =====
  const player = {
    x:0, y:0, vx:0, vy:0,
    w:26, h:34,
    onGround:false,
    realOnGround:false,
    perceivedOnGround:false,
    jumpWasDown:false,
  };

  // ===== Meta =====
  const meta = {
    t0: performance.now(),
    timeToFirstJumpMs: null,
    jumpCount: 0,
    deaths: 0,
    lastDeathReason: "",
    hesitationMs: 0,
    lastMoveTime: performance.now(),
    completed: false,
    finishTimeMs: null,
    levelStarts: 0,
  };

  // ===== Delay queues / camera =====
  const feedbackQueue = [];
  const camQueue = [];
  const cam = { x:0, y:0, tx:0, ty:0 };

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function aabb(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function resetLevel(isLoad=false){
    // IMPORTANT: hard reset always clears completed state + queues
    meta.t0 = performance.now();
    meta.timeToFirstJumpMs = null;
    meta.jumpCount = 0;
    meta.deaths = 0;
    meta.lastDeathReason = "";
    meta.hesitationMs = 0;
    meta.lastMoveTime = performance.now();
    meta.completed = false;
    meta.finishTimeMs = null;
    meta.levelStarts += 1;

    player.x = world.start.x;
    player.y = world.start.y;
    player.vx = 0; player.vy = 0;
    player.onGround = false;
    player.realOnGround = false;
    player.perceivedOnGround = false;
    player.jumpWasDown = false;

    feedbackQueue.length = 0;
    camQueue.length = 0;
    cam.x = 0; cam.y = 0; cam.tx = 0; cam.ty = 0;

    els.comment.textContent = isLoad ? "—" : els.comment.textContent;
    renderHUD();
  }

  function pushFeedback(groundNow){
    if (!CFG.delayEnabled){
      player.perceivedOnGround = groundNow;
      return;
    }
    feedbackQueue.push({ t: performance.now() + CFG.feedbackDelayMs, ground: groundNow });
  }

  function pushCamTarget(tx, ty){
    if (!CFG.delayEnabled){
      cam.tx = tx; cam.ty = ty;
      return;
    }
    camQueue.push({ t: performance.now() + CFG.camDelayMs, targetX: tx, targetY: ty });
  }

  function processQueues(now){
    while (feedbackQueue.length && feedbackQueue[0].t <= now){
      player.perceivedOnGround = feedbackQueue.shift().ground;
    }
    while (camQueue.length && camQueue[0].t <= now){
      const e = camQueue.shift();
      cam.tx = e.targetX; cam.ty = e.targetY;
    }
  }

  function moveAndCollide(dt){
    // horizontal
    player.x += player.vx * dt;
    for (const s of world.solids){
      if (aabb({x:player.x,y:player.y,w:player.w,h:player.h}, s)){
        if (player.vx > 0) player.x = s.x - player.w;
        else if (player.vx < 0) player.x = s.x + s.w;
        player.vx = 0;
      }
    }

    // vertical
    player.y += player.vy * dt;
    player.realOnGround = false;
    for (const s of world.solids){
      if (aabb({x:player.x,y:player.y,w:player.w,h:player.h}, s)){
        if (player.vy > 0){
          player.y = s.y - player.h;
          player.vy = 0;
          player.realOnGround = true;
        } else if (player.vy < 0){
          player.y = s.y + s.h;
          player.vy = 0;
        }
      }
    }
    player.onGround = player.realOnGround;

    // hesitation
    const moving = Math.abs(player.vx) > 10 || Math.abs(player.vy) > 10 || down("left") || down("right");
    if (moving) meta.lastMoveTime = performance.now();
    else meta.hesitationMs = performance.now() - meta.lastMoveTime;

    // hazards
    const pbox = {x:player.x,y:player.y,w:player.w,h:player.h};
    for (const sp of world.spikes){
      if (aabb(pbox, {x:sp.x,y:sp.y-8,w:sp.w,h:sp.h+8})){
        die("Spikes");
        return;
      }
    }
    if (player.y > 900){
      die("Fall");
      return;
    }

    // goal
    if (!meta.completed && aabb(pbox, world.goal)){
      meta.completed = true;
      meta.finishTimeMs = performance.now() - meta.t0;
      postComment(false);

      // auto-advance after short delay (feels nice)
      setTimeout(() => {
        loadLevel(levelIndex + 1);
      }, 450);
    }

    pushFeedback(player.realOnGround);
  }

  function die(reason){
    meta.deaths += 1;
    meta.lastDeathReason = reason;

    player.x = world.start.x;
    player.y = world.start.y;
    player.vx = 0; player.vy = 0;
    player.onGround = false;
    player.realOnGround = false;

    feedbackQueue.length = 0;
    player.perceivedOnGround = false;
    pushFeedback(false);

    meta.lastMoveTime = performance.now();
    meta.hesitationMs = 0;

    if (meta.deaths === 1 || meta.deaths === 3) postComment(true);
  }

  function postComment(intermediate){
    const now = performance.now();
    const t = now - meta.t0;
    const firstJump = meta.timeToFirstJumpMs;
    const jps = meta.jumpCount / Math.max(1, t/1000);
    const hes = meta.hesitationMs;

    let line;
    if (meta.completed){
      line = "Die Regeln haben sich nicht geändert. Nur dein Vertrauen.";
    } else if (firstJump !== null && firstJump > 1800) {
      line = "Du wartest oft, bevor du springst – als müsste etwas passieren.";
    } else if (jps > 0.95) {
      line = "Du springst viel. Vielleicht, um dich nicht entscheiden zu müssen.";
    } else if (meta.deaths >= 2) {
      line = "Du machst denselben Fehler nicht zweimal. Du machst ihn nur ähnlich.";
    } else if (hes > 1200) {
      line = "Du bleibst stehen, als könntest du das Timing damit beeinflussen.";
    } else {
      line = "Du vertraust dem ersten Impuls. Das ist selten falsch.";
    }

    if (intermediate && meta.lastDeathReason){
      line += ` (${meta.lastDeathReason} ist nur eine Bezeichnung.)`;
    }
    els.comment.textContent = line;
  }

  function msToS(ms){ return (ms/1000).toFixed(2); }

  function renderHUD(){
    const now = performance.now();
    const elapsed = meta.completed ? meta.finishTimeMs : (now - meta.t0);
    const jps = meta.jumpCount / Math.max(1, elapsed/1000);

    const pills = [
      `Level: <b>${LEVELS[levelIndex].name}</b>`,
      `Zeit: <b>${msToS(elapsed)}</b>s`,
      `Sprünge: <b>${meta.jumpCount}</b> (<b>${jps.toFixed(2)}</b>/s)`,
      `Tode: <b>${meta.deaths}</b>`,
    ];

    els.hud.innerHTML = pills.map(p => `<div class="pill">${p}</div>`).join("");

    els.btnDelay.textContent = `Delay: ${CFG.delayEnabled ? "an" : "aus"}`;
  }

  // ===== Touch zones =====
  function isTouchDevice(){
    return ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);
  }

  function enableTouchZones(){
    if (!isTouchDevice()) return;
    els.touchZones.style.display = "block";

    const activePointers = new Map();

    const clearMove = () => {
      touchKeys.set("arrowleft", false);
      touchKeys.set("arrowright", false);
      els.indLeft.classList.remove("active");
      els.indRight.classList.remove("active");
    };
    const clearJump = () => touchKeys.set(" ", false);

    function applyMoveFromX(clientX){
      const r = els.zoneMove.getBoundingClientRect();
      const x = clamp(clientX - r.left, 0, r.width);
      const leftSide = x < r.width * 0.5;
      if (leftSide){
        touchKeys.set("arrowleft", true);
        touchKeys.set("arrowright", false);
        els.indLeft.classList.add("active");
        els.indRight.classList.remove("active");
        return "left";
      } else {
        touchKeys.set("arrowleft", false);
        touchKeys.set("arrowright", true);
        els.indLeft.classList.remove("active");
        els.indRight.classList.add("active");
        return "right";
      }
    }

    function bindZone(el, zoneName){
      el.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        el.setPointerCapture(e.pointerId);

        if (zoneName === "move"){
          const side = applyMoveFromX(e.clientX);
          activePointers.set(e.pointerId, { zone:"move", side });
        } else {
          touchKeys.set(" ", true);
          activePointers.set(e.pointerId, { zone:"jump", side:null });
        }
      }, { passive:false });

      el.addEventListener("pointermove", (e) => {
        const st = activePointers.get(e.pointerId);
        if (!st) return;
        if (st.zone === "move"){
          st.side = applyMoveFromX(e.clientX);
        }
      }, { passive:false });

      const endPointer = (e) => {
        const st = activePointers.get(e.pointerId);
        if (!st) return;
        activePointers.delete(e.pointerId);

        if (st.zone === "move"){
          let stillMove = false;
          for (const v of activePointers.values()) if (v.zone === "move") { stillMove = true; break; }
          if (!stillMove) clearMove();
        } else {
          let stillJump = false;
          for (const v of activePointers.values()) if (v.zone === "jum
